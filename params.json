{"name":"luastar","tagline":"一个用lua实现的基于openresty的接口(api)开发框架","body":"#luastar\r\n##1. 简介\r\nluastar是一个基于[openresty](http://openresty.org/cn/index.html)的高性能高并发开发框架，主要用于移动端app的http接口开发，实现了request/response、缓存、配置文件、路由/拦截器、bean管理、mysql和redis以及httpclient等常用工具类的封装，便于快速开发。\r\n##2. 安装\r\n###2.1 openresty 安装\r\n请参考官网介绍，建议安装目录：/usr/local/openresty\r\n###2.2 luastar 安装\r\n下载项目到到硬盘上，如：/data/apps/luastar下。\r\n可修改配置文件(luastar/conf/luastar*.conf)中的相关路径为openresty安装路径和项目存放路径，可配置多个不同环境的配置文件。\r\n例如：\r\n开发环境（luastar_dev.conf）中增加了调试工具路径并关闭了代码缓存。\r\n开发调试可使用[ZeroBrane Studio](http://studio.zerobrane.com/)，详细请参考后继章节。\r\n关闭代码缓存可在修改代码后不必每次重启nginx。\r\n###2.3 nginx 配置\r\n修改 openresty/nginx/conf/nginx.conf，最后一行增加：\r\ninclude /data/apps/luastar/luastar/conf/luastar_dev.conf;\r\n###2.4 hello world\r\n启动openresty：\r\nopenresty/nginx/sbin/nginx -c openresty/nginx/conf/nginx.conf\r\n\r\n访问 http://localhost:8001/api/test/hello，\r\n试试带参数访问 http://localhost:8001/api/test/hello?name=haha\r\n\r\n##3. 开始\r\n###3.1 项目结构\r\n* luastar\r\n* |----luastar\r\n* |--------conf（nginx配置文件）\r\n* |--------libs（第三方库）\r\n* |--------src（luastar源码）\r\n* |----demo1（项目1）\r\n* |--------config（项目配置）\r\n* |------------app.lua（项目配置文件）\r\n* |------------bean.lua（bean配置文件）\r\n* |------------route.lua（路由/拦截器配置文件）\r\n* |--------src（项目源码）\r\n* |------------com\r\n* |----------------luastar\r\n* |--------------------demo\r\n* |------------------------ctrl（控制类-业务逻辑）\r\n* |------------------------interceptor（拦截器）\r\n* |------------------------service（服务类-公共服务）\r\n* |------------------------util（常用类）\r\n* |----demo2（项目2）\r\n* |--------config（项目配置）\r\n* |--------src（项目源码）\r\n\r\n###3.2 全局变量\r\nluastar在初始化时，定义了几个常用的工具，在项目中可以直接使用，不用require引入。\r\n参看：luastar/src/luastar_init.lua\r\n|变量名|用途|\r\n|--|--|\r\n|Class|类定义|\r\n|cjson|json处理类|\r\n|_|Moses常用工具类|\r\n|luastar_cache|缓存|\r\n|luastar_config|配置|\r\n|luastar_context|上下文|\r\n|logger|日志辅助|\r\n\r\n第三方工具类：\r\n* [csjon](http://www.kyne.com.au/~mark/software/lua-cjson.php)\r\n* [moses](https://github.com/Yonaba/Moses)\r\n* [http](https://github.com/liseen/lua-resty-http)\r\n* ...\r\n\r\n###3.3 缓存\r\n在项目中，如果有需要缓存的数据，可使用luastar_cache来存放和读取\r\n```lua\r\nluastar_cache.get(\"app_config\")\r\nluastar_cache.set(\"app_config\", app_config)\r\n```\r\n注：luastar的缓存根据openresty的机制，每个nginx的worker会存放一份，如果需要在worker中共用，请使用openresty提供的字典（支持的数据结构有限）\r\n\r\n###3.4 上下文\r\n```lua\r\n--获取路由\r\nlocal route = luastar_context.getRoute()\r\n--获取bean\r\nlocal beanFactory = luastar_context.getBeanFactory()\r\nlocal redis_util = beanFactory:getBean(\"redis\")\r\n```\r\n###3.5 日志\r\nluastar日志直接使用openresty中提供的ngx.log实现，之前有使用第三方log包写文件，但效果不太理想，容易丢失日志。\r\nluastar提供了一个辅助类，主要用于日志跟踪。\r\n```lua\r\nngx.log(logger.info(p1,p2,p3,...))\r\n-- 也可以使用简写\r\nngx.log(logger.i(p1,p2,p3,...))\r\n```\r\n设计在每个请求头中增加一个参数random，如果客户端传入了此参数，则直接使用，如果没传，则随机生成，在使用上述方式输出的日志中都会带有该标识，例如：--[ECekJjHCK5]--。\r\n```log\r\n2015/12/14 13:31:06 [info] 3102#0: *26 [lua] common.lua:20: --[3SLqq8d1Zn]--request header is {\"datakey\":\"\",\"random\":\"3SLqq8d1Zn\",\"ostype\":\"\",\"appkey\":\"\",\"appversion\":\"\"}, client: 127.0.0.1, server: localhost, request: \"GET /api/test/hello HTTP/1.1\", host: \"localhost:8001\"\r\n```\r\n###3.6 配置文件\r\n项目配置可根据不同环境配置多个，\r\n例如在测试环境的luastar/conf/luastar_test.conf中设置：\r\nset $APP_CONFIG '/config/app_test.lua';\r\n```conf\r\nserver {\r\n  listen 8001;\r\n  server_name localhost;\r\n  set $LUASTAR_PATH '/data/apps/luastar/luastar';\r\n  set $APP_NAME 'demo';\r\n  set $APP_PATH '/data/apps/luastar/demo';\r\n  set $APP_CONFIG '/config/app_test.lua';\r\n  access_log /data/logs/demo/access.log  main;\r\n  error_log  /data/logs/demo/error.log   info;\r\n  location / {\r\n    default_type text/html;\r\n    content_by_lua_file '${LUASTAR_PATH}/src/luastar_content.lua';\r\n  }\r\n}\r\n```\r\n配置文件直接使用lua语法，例如：\r\n```lua\r\n--[[\r\n应用配置文件\r\n--]]\r\nmysql = {\r\n    host = \"localhost\",\r\n    port = \"3306\",\r\n    user = \"admin\",\r\n    password = \"xxx\",\r\n    database = \"xxx\",\r\n    timeout = 30000,\r\n    pool_size = 1000\r\n}\r\nredis = {\r\n    host = \"localhost\",\r\n    port = \"6379\",\r\n    auth = \"xxx\",\r\n    timeout = 30000,\r\n    pool_size = 1000\r\n}\r\nweixin = {\r\n  access_token_url = \"https://api.weixin.qq.com/sns/oauth2/access_token\",\r\n  check_token_url = \"https://api.weixin.qq.com/sns/auth\",\r\n  refresh_token_url = \"https://api.weixin.qq.com/sns/oauth2/refresh_token\",\r\n  userinfo_url = \"https://api.weixin.qq.com/sns/userinfo\"\r\n}\r\n```\r\n在代码中可通过luastar_config.getConfig来获取：\r\n```lua\r\nlocal access_token_url = luastar_config.getConfig(\"weixin\")[\"access_token_url\"]\r\n```\r\n也可以在bean.conf中通过${weixin.access_token_url}获取\r\n```lua\r\nmysql = {\r\n    class = \"luastar.db.mysql\",\r\n    arg = {\r\n        { value = \"${mysql}\" }\r\n    }\r\n}\r\n```\r\n配置文件在nginx启动时读取，并存放在缓存中。\r\n###3.7 路由和拦截器\r\n路由和拦截器在demo/conf/route.lua文件中配置，例如：\r\n```lua\r\nroute = {\r\n    { \"/api/test/hello\", \"com.luastar.demo.ctrl.test.hello\", \"hello\" },\r\n    { \"/api/test/mysql\", \"com.luastar.demo.ctrl.test.mysql\", \"mysql\" },\r\n    { \"/api/test/mysql/transaction\", \"com.luastar.demo.ctrl.test.mysql\", \"transaction\" },\r\n    { \"/api/test/redis\", \"com.luastar.demo.ctrl.test.redis\", \"redis\" },\r\n    { \"/api/test/baidu\", \"com.luastar.demo.ctrl.test.httpclient\", \"baidu\" },\r\n    { \"/api/test/form\", \"com.luastar.demo.ctrl.test.form\", \"form\" }\r\n}\r\n\r\ninterceptor = {\r\n    {\r\n        url = \"/api\",\r\n        class = \"com.luastar.demo.interceptor.common\"\r\n    }\r\n}\r\n```\r\n路由是一个二维数组，每一行表示一个接口地址，第一列表示请求地址（目前只支持全匹配），第二列表示对应的处理类，第三列表示处理类中的方法。\r\n例如：当请求http://localhost:8001/api/test/hello时，由com.luastar.demo.ctrl.test.hello类的hello方法处理。\r\n拦截器与路由稍有不同，每一行指定了属性，url代表拦截的请求，支持lua的模式匹配，class代表拦截器实现，excludes表示排除不处理的请求。\r\n```lua\r\ninterceptor = {\r\n  {url=\"url1\", class=\"file\"},\r\n  {url=\"url2\", class=\"file\", excludes={\"url1\",\"url2\"}}\r\n}\r\n```\r\n拦截器必须实现beforeHandle和afterHandle方法\r\nbeforeHandle方法返回一个布尔类型的值，返回true继续执行后续处理，返回false中止退出。\r\n###3.8 bean配置\r\n简化版的spring bean管理，\r\n```lua\r\nid = {\t--bean id\r\n  class = \"\", --类地址\r\n  arg = { --构造参数注入\r\n    {value/ref = \"\"} --value直接赋值，ref引用其他bean\r\n  },\r\n  property = { --set方法注入，必须实现set_${name}方法\r\n    {name = \"\",value/ref = \"\"}\r\n  },\r\n  init_method = \"\",--初始化方法，默认使用init()\r\n  single = 0  -- 是否单例，默认是\r\n}\r\n```\r\n例如：\r\n```lua\r\nmysql = {\r\n    class = \"luastar.db.mysql\",\r\n    arg = {\r\n        { value = \"${mysql}\" }\r\n    }\r\n}\r\nredis = {\r\n    class = \"luastar.db.redis\",\r\n    arg = {\r\n        { value = \"${redis}\" }\r\n    }\r\n}\r\nparamService = {\r\n    class = \"com.lajin.service.common.paramService\"\r\n}\r\ntestService = {\r\n    class = \"com.lajin.service.test.testService\",\r\n    arg = { { ref = \"redis\" } }\r\n}\r\n```\r\n注：在类中定义的方法最好使用类的模式，可以使用luastar框架中的class类定义：\r\n```lua\r\nlocal testService = Class(\"com.luastar.demo.service.test.testService\")\r\nlocal table_util = require(\"luastar.util.table\")\r\n\r\nfunction testService:init(redis_util)\r\n    self.redis_util = redis_util\r\nend\r\n\r\n--[[\r\n-- 根据uid获取用户信息\r\n--]]\r\nfunction testService:getUserInfo(uid)\r\n    if _.isEmpty(uid) then\r\n        return nil\r\n    end\r\n    local redis = self.redis_util:getConnect()\r\n    local userinfo = table_util.array_to_hash(redis:hgetall(\"user:info:\" .. uid))\r\n    self.redis_util:close(redis)\r\n    if _.isEmpty(userinfo) then\r\n        ngx.log(logger.e(\"userinfo is empty, uid=\", uid))\r\n        return nil\r\n    end\r\n    ngx.log(logger.i(cjson.encode(userinfo)))\r\n    return userinfo\r\nend\r\n\r\nreturn testService\r\n```\r\n\r\n在代码中调用：\r\n```lua\r\nlocal beanFactory = luastar_context.getBeanFactory()\r\nlocal mysql_util = beanFactory:getBean(\"mysql\")\r\n```\r\n###3.9 ctrl类\r\n默认给ctrl类的请求处理方法传入了request和response对象，也可通过ngx.ctx.request和ngx.ctx.response获取\r\n```lua\r\nfunction hello(request, response)\r\n    local name = request:get_arg(\"name\") or \"world, try to give a param with name.\"\r\n    response:writeln(\"hello, \" .. name)\r\nend\r\n```\r\n可以通过request:get_arg(\"name\", \"default\")获取参数，支持get、post参数，支持文件上传。","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}